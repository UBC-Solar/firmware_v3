/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "mock_ltc6813_btm.h"

static const char* CMockString_BTM_calculatePec15 = "BTM_calculatePec15";
static const char* CMockString_BTM_init = "BTM_init";
static const char* CMockString_BTM_readBatt = "BTM_readBatt";
static const char* CMockString_BTM_readRegisterGroup = "BTM_readRegisterGroup";
static const char* CMockString_BTM_regValToVoltage = "BTM_regValToVoltage";
static const char* CMockString_BTM_sendCmd = "BTM_sendCmd";
static const char* CMockString_BTM_sendCmdAndPoll = "BTM_sendCmdAndPoll";
static const char* CMockString_BTM_wakeup = "BTM_wakeup";
static const char* CMockString_BTM_writeCS = "BTM_writeCS";
static const char* CMockString_BTM_writeRegisterGroup = "BTM_writeRegisterGroup";
static const char* CMockString_command = "command";
static const char* CMockString_data = "data";
static const char* CMockString_len = "len";
static const char* CMockString_new_state = "new_state";
static const char* CMockString_pack = "pack";
static const char* CMockString_packData = "packData";
static const char* CMockString_raw_reading = "raw_reading";
static const char* CMockString_rx_data = "rx_data";
static const char* CMockString_tx_data = "tx_data";

typedef struct _CMOCK_BTM_calculatePec15_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint16_t ReturnVal;
  int CallOrder;
  uint8_t* Expected_data;
  int Expected_len;

} CMOCK_BTM_calculatePec15_CALL_INSTANCE;

typedef struct _CMOCK_BTM_init_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  BTM_PackData_t* Expected_pack;

} CMOCK_BTM_init_CALL_INSTANCE;

typedef struct _CMOCK_BTM_wakeup_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;

} CMOCK_BTM_wakeup_CALL_INSTANCE;

typedef struct _CMOCK_BTM_sendCmd_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  BTM_command_t Expected_command;

} CMOCK_BTM_sendCmd_CALL_INSTANCE;

typedef struct _CMOCK_BTM_sendCmdAndPoll_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BTM_Status_t ReturnVal;
  int CallOrder;
  BTM_command_t Expected_command;

} CMOCK_BTM_sendCmdAndPoll_CALL_INSTANCE;

typedef struct _CMOCK_BTM_writeRegisterGroup_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  BTM_command_t Expected_command;
  uint8_t** Expected_tx_data;

} CMOCK_BTM_writeRegisterGroup_CALL_INSTANCE;

typedef struct _CMOCK_BTM_readRegisterGroup_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BTM_Status_t ReturnVal;
  int CallOrder;
  BTM_command_t Expected_command;
  uint8_t** Expected_rx_data;

} CMOCK_BTM_readRegisterGroup_CALL_INSTANCE;

typedef struct _CMOCK_BTM_readBatt_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BTM_Status_t ReturnVal;
  int CallOrder;
  BTM_PackData_t* Expected_packData;

} CMOCK_BTM_readBatt_CALL_INSTANCE;

typedef struct _CMOCK_BTM_regValToVoltage_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  float ReturnVal;
  int CallOrder;
  unsigned int Expected_raw_reading;

} CMOCK_BTM_regValToVoltage_CALL_INSTANCE;

typedef struct _CMOCK_BTM_writeCS_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  CS_state_t Expected_new_state;

} CMOCK_BTM_writeCS_CALL_INSTANCE;

static struct mock_ltc6813_btmInstance
{
  char BTM_calculatePec15_IgnoreBool;
  uint16_t BTM_calculatePec15_FinalReturn;
  char BTM_calculatePec15_CallbackBool;
  CMOCK_BTM_calculatePec15_CALLBACK BTM_calculatePec15_CallbackFunctionPointer;
  int BTM_calculatePec15_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE BTM_calculatePec15_CallInstance;
  char BTM_init_IgnoreBool;
  char BTM_init_CallbackBool;
  CMOCK_BTM_init_CALLBACK BTM_init_CallbackFunctionPointer;
  int BTM_init_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE BTM_init_CallInstance;
  char BTM_wakeup_IgnoreBool;
  char BTM_wakeup_CallbackBool;
  CMOCK_BTM_wakeup_CALLBACK BTM_wakeup_CallbackFunctionPointer;
  int BTM_wakeup_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE BTM_wakeup_CallInstance;
  char BTM_sendCmd_IgnoreBool;
  char BTM_sendCmd_CallbackBool;
  CMOCK_BTM_sendCmd_CALLBACK BTM_sendCmd_CallbackFunctionPointer;
  int BTM_sendCmd_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE BTM_sendCmd_CallInstance;
  char BTM_sendCmdAndPoll_IgnoreBool;
  BTM_Status_t BTM_sendCmdAndPoll_FinalReturn;
  char BTM_sendCmdAndPoll_CallbackBool;
  CMOCK_BTM_sendCmdAndPoll_CALLBACK BTM_sendCmdAndPoll_CallbackFunctionPointer;
  int BTM_sendCmdAndPoll_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE BTM_sendCmdAndPoll_CallInstance;
  char BTM_writeRegisterGroup_IgnoreBool;
  char BTM_writeRegisterGroup_CallbackBool;
  CMOCK_BTM_writeRegisterGroup_CALLBACK BTM_writeRegisterGroup_CallbackFunctionPointer;
  int BTM_writeRegisterGroup_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE BTM_writeRegisterGroup_CallInstance;
  char BTM_readRegisterGroup_IgnoreBool;
  BTM_Status_t BTM_readRegisterGroup_FinalReturn;
  char BTM_readRegisterGroup_CallbackBool;
  CMOCK_BTM_readRegisterGroup_CALLBACK BTM_readRegisterGroup_CallbackFunctionPointer;
  int BTM_readRegisterGroup_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE BTM_readRegisterGroup_CallInstance;
  char BTM_readBatt_IgnoreBool;
  BTM_Status_t BTM_readBatt_FinalReturn;
  char BTM_readBatt_CallbackBool;
  CMOCK_BTM_readBatt_CALLBACK BTM_readBatt_CallbackFunctionPointer;
  int BTM_readBatt_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE BTM_readBatt_CallInstance;
  char BTM_regValToVoltage_IgnoreBool;
  float BTM_regValToVoltage_FinalReturn;
  char BTM_regValToVoltage_CallbackBool;
  CMOCK_BTM_regValToVoltage_CALLBACK BTM_regValToVoltage_CallbackFunctionPointer;
  int BTM_regValToVoltage_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE BTM_regValToVoltage_CallInstance;
  char BTM_writeCS_IgnoreBool;
  char BTM_writeCS_CallbackBool;
  CMOCK_BTM_writeCS_CALLBACK BTM_writeCS_CallbackFunctionPointer;
  int BTM_writeCS_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE BTM_writeCS_CallInstance;
} Mock;

extern jmp_buf AbortFrame;
extern int GlobalExpectCount;
extern int GlobalVerifyOrder;

void mock_ltc6813_btm_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.BTM_calculatePec15_CallInstance;
  if (Mock.BTM_calculatePec15_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_BTM_calculatePec15);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.BTM_calculatePec15_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.BTM_init_CallInstance;
  if (Mock.BTM_init_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_BTM_init);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.BTM_init_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.BTM_wakeup_CallInstance;
  if (Mock.BTM_wakeup_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_BTM_wakeup);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.BTM_wakeup_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.BTM_sendCmd_CallInstance;
  if (Mock.BTM_sendCmd_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_BTM_sendCmd);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.BTM_sendCmd_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.BTM_sendCmdAndPoll_CallInstance;
  if (Mock.BTM_sendCmdAndPoll_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_BTM_sendCmdAndPoll);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.BTM_sendCmdAndPoll_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.BTM_writeRegisterGroup_CallInstance;
  if (Mock.BTM_writeRegisterGroup_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_BTM_writeRegisterGroup);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.BTM_writeRegisterGroup_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.BTM_readRegisterGroup_CallInstance;
  if (Mock.BTM_readRegisterGroup_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_BTM_readRegisterGroup);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.BTM_readRegisterGroup_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.BTM_readBatt_CallInstance;
  if (Mock.BTM_readBatt_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_BTM_readBatt);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.BTM_readBatt_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.BTM_regValToVoltage_CallInstance;
  if (Mock.BTM_regValToVoltage_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_BTM_regValToVoltage);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.BTM_regValToVoltage_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.BTM_writeCS_CallInstance;
  if (Mock.BTM_writeCS_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_BTM_writeCS);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.BTM_writeCS_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
}

void mock_ltc6813_btm_Init(void)
{
  mock_ltc6813_btm_Destroy();
}

void mock_ltc6813_btm_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
  GlobalExpectCount = 0;
  GlobalVerifyOrder = 0;
}

uint16_t BTM_calculatePec15(uint8_t* data, int len)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_BTM_calculatePec15_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_BTM_calculatePec15);
  cmock_call_instance = (CMOCK_BTM_calculatePec15_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.BTM_calculatePec15_CallInstance);
  Mock.BTM_calculatePec15_CallInstance = CMock_Guts_MemNext(Mock.BTM_calculatePec15_CallInstance);
  if (Mock.BTM_calculatePec15_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.BTM_calculatePec15_FinalReturn;
    Mock.BTM_calculatePec15_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.BTM_calculatePec15_CallbackBool &&
      Mock.BTM_calculatePec15_CallbackFunctionPointer != NULL)
  {
    uint16_t cmock_cb_ret = Mock.BTM_calculatePec15_CallbackFunctionPointer(data, len, Mock.BTM_calculatePec15_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_BTM_calculatePec15,CMockString_data);
    if (cmock_call_instance->Expected_data == NULL)
      { UNITY_TEST_ASSERT_NULL(data, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_data, data, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_BTM_calculatePec15,CMockString_len);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_len, len, cmock_line, CMockStringMismatch);
  }
  if (Mock.BTM_calculatePec15_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.BTM_calculatePec15_CallbackFunctionPointer(data, len, Mock.BTM_calculatePec15_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_BTM_calculatePec15(CMOCK_BTM_calculatePec15_CALL_INSTANCE* cmock_call_instance, uint8_t* data, int len);
void CMockExpectParameters_BTM_calculatePec15(CMOCK_BTM_calculatePec15_CALL_INSTANCE* cmock_call_instance, uint8_t* data, int len)
{
  cmock_call_instance->Expected_data = data;
  cmock_call_instance->Expected_len = len;
}

void BTM_calculatePec15_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_BTM_calculatePec15_CALL_INSTANCE));
  CMOCK_BTM_calculatePec15_CALL_INSTANCE* cmock_call_instance = (CMOCK_BTM_calculatePec15_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.BTM_calculatePec15_CallInstance = CMock_Guts_MemChain(Mock.BTM_calculatePec15_CallInstance, cmock_guts_index);
  Mock.BTM_calculatePec15_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.BTM_calculatePec15_IgnoreBool = (char)1;
}

void BTM_calculatePec15_CMockStopIgnore(void)
{
  if(Mock.BTM_calculatePec15_IgnoreBool)
    Mock.BTM_calculatePec15_CallInstance = CMock_Guts_MemNext(Mock.BTM_calculatePec15_CallInstance);
  Mock.BTM_calculatePec15_IgnoreBool = (char)0;
}

void BTM_calculatePec15_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* data, int len, uint16_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_BTM_calculatePec15_CALL_INSTANCE));
  CMOCK_BTM_calculatePec15_CALL_INSTANCE* cmock_call_instance = (CMOCK_BTM_calculatePec15_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.BTM_calculatePec15_CallInstance = CMock_Guts_MemChain(Mock.BTM_calculatePec15_CallInstance, cmock_guts_index);
  Mock.BTM_calculatePec15_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_BTM_calculatePec15(cmock_call_instance, data, len);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void BTM_calculatePec15_AddCallback(CMOCK_BTM_calculatePec15_CALLBACK Callback)
{
  Mock.BTM_calculatePec15_IgnoreBool = (char)0;
  Mock.BTM_calculatePec15_CallbackBool = (char)1;
  Mock.BTM_calculatePec15_CallbackFunctionPointer = Callback;
}

void BTM_calculatePec15_Stub(CMOCK_BTM_calculatePec15_CALLBACK Callback)
{
  Mock.BTM_calculatePec15_IgnoreBool = (char)0;
  Mock.BTM_calculatePec15_CallbackBool = (char)0;
  Mock.BTM_calculatePec15_CallbackFunctionPointer = Callback;
}

void BTM_init(BTM_PackData_t * pack)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_BTM_init_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_BTM_init);
  cmock_call_instance = (CMOCK_BTM_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.BTM_init_CallInstance);
  Mock.BTM_init_CallInstance = CMock_Guts_MemNext(Mock.BTM_init_CallInstance);
  if (Mock.BTM_init_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.BTM_init_CallbackBool &&
      Mock.BTM_init_CallbackFunctionPointer != NULL)
  {
    Mock.BTM_init_CallbackFunctionPointer(pack, Mock.BTM_init_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_BTM_init,CMockString_pack);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pack), (void*)(pack), sizeof(BTM_PackData_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.BTM_init_CallbackFunctionPointer != NULL)
  {
    Mock.BTM_init_CallbackFunctionPointer(pack, Mock.BTM_init_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_BTM_init(CMOCK_BTM_init_CALL_INSTANCE* cmock_call_instance, BTM_PackData_t* pack);
void CMockExpectParameters_BTM_init(CMOCK_BTM_init_CALL_INSTANCE* cmock_call_instance, BTM_PackData_t* pack)
{
  cmock_call_instance->Expected_pack = pack;
}

void BTM_init_CMockIgnore(void)
{
  Mock.BTM_init_IgnoreBool = (char)1;
}

void BTM_init_CMockStopIgnore(void)
{
  Mock.BTM_init_IgnoreBool = (char)0;
}

void BTM_init_CMockExpect(UNITY_LINE_TYPE cmock_line, BTM_PackData_t* pack)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_BTM_init_CALL_INSTANCE));
  CMOCK_BTM_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_BTM_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.BTM_init_CallInstance = CMock_Guts_MemChain(Mock.BTM_init_CallInstance, cmock_guts_index);
  Mock.BTM_init_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_BTM_init(cmock_call_instance, pack);
}

void BTM_init_AddCallback(CMOCK_BTM_init_CALLBACK Callback)
{
  Mock.BTM_init_IgnoreBool = (char)0;
  Mock.BTM_init_CallbackBool = (char)1;
  Mock.BTM_init_CallbackFunctionPointer = Callback;
}

void BTM_init_Stub(CMOCK_BTM_init_CALLBACK Callback)
{
  Mock.BTM_init_IgnoreBool = (char)0;
  Mock.BTM_init_CallbackBool = (char)0;
  Mock.BTM_init_CallbackFunctionPointer = Callback;
}

void BTM_wakeup(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_BTM_wakeup_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_BTM_wakeup);
  cmock_call_instance = (CMOCK_BTM_wakeup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.BTM_wakeup_CallInstance);
  Mock.BTM_wakeup_CallInstance = CMock_Guts_MemNext(Mock.BTM_wakeup_CallInstance);
  if (Mock.BTM_wakeup_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.BTM_wakeup_CallbackBool &&
      Mock.BTM_wakeup_CallbackFunctionPointer != NULL)
  {
    Mock.BTM_wakeup_CallbackFunctionPointer(Mock.BTM_wakeup_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.BTM_wakeup_CallbackFunctionPointer != NULL)
  {
    Mock.BTM_wakeup_CallbackFunctionPointer(Mock.BTM_wakeup_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void BTM_wakeup_CMockIgnore(void)
{
  Mock.BTM_wakeup_IgnoreBool = (char)1;
}

void BTM_wakeup_CMockStopIgnore(void)
{
  Mock.BTM_wakeup_IgnoreBool = (char)0;
}

void BTM_wakeup_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_BTM_wakeup_CALL_INSTANCE));
  CMOCK_BTM_wakeup_CALL_INSTANCE* cmock_call_instance = (CMOCK_BTM_wakeup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.BTM_wakeup_CallInstance = CMock_Guts_MemChain(Mock.BTM_wakeup_CallInstance, cmock_guts_index);
  Mock.BTM_wakeup_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
}

void BTM_wakeup_AddCallback(CMOCK_BTM_wakeup_CALLBACK Callback)
{
  Mock.BTM_wakeup_IgnoreBool = (char)0;
  Mock.BTM_wakeup_CallbackBool = (char)1;
  Mock.BTM_wakeup_CallbackFunctionPointer = Callback;
}

void BTM_wakeup_Stub(CMOCK_BTM_wakeup_CALLBACK Callback)
{
  Mock.BTM_wakeup_IgnoreBool = (char)0;
  Mock.BTM_wakeup_CallbackBool = (char)0;
  Mock.BTM_wakeup_CallbackFunctionPointer = Callback;
}

void BTM_sendCmd(BTM_command_t command)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_BTM_sendCmd_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_BTM_sendCmd);
  cmock_call_instance = (CMOCK_BTM_sendCmd_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.BTM_sendCmd_CallInstance);
  Mock.BTM_sendCmd_CallInstance = CMock_Guts_MemNext(Mock.BTM_sendCmd_CallInstance);
  if (Mock.BTM_sendCmd_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.BTM_sendCmd_CallbackBool &&
      Mock.BTM_sendCmd_CallbackFunctionPointer != NULL)
  {
    Mock.BTM_sendCmd_CallbackFunctionPointer(command, Mock.BTM_sendCmd_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_BTM_sendCmd,CMockString_command);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_command), (void*)(&command), sizeof(BTM_command_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.BTM_sendCmd_CallbackFunctionPointer != NULL)
  {
    Mock.BTM_sendCmd_CallbackFunctionPointer(command, Mock.BTM_sendCmd_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_BTM_sendCmd(CMOCK_BTM_sendCmd_CALL_INSTANCE* cmock_call_instance, BTM_command_t command);
void CMockExpectParameters_BTM_sendCmd(CMOCK_BTM_sendCmd_CALL_INSTANCE* cmock_call_instance, BTM_command_t command)
{
  memcpy((void*)(&cmock_call_instance->Expected_command), (void*)(&command),
         sizeof(BTM_command_t[sizeof(command) == sizeof(BTM_command_t) ? 1 : -1])); /* add BTM_command_t to :treat_as_array if this causes an error */
}

void BTM_sendCmd_CMockIgnore(void)
{
  Mock.BTM_sendCmd_IgnoreBool = (char)1;
}

void BTM_sendCmd_CMockStopIgnore(void)
{
  Mock.BTM_sendCmd_IgnoreBool = (char)0;
}

void BTM_sendCmd_CMockExpect(UNITY_LINE_TYPE cmock_line, BTM_command_t command)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_BTM_sendCmd_CALL_INSTANCE));
  CMOCK_BTM_sendCmd_CALL_INSTANCE* cmock_call_instance = (CMOCK_BTM_sendCmd_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.BTM_sendCmd_CallInstance = CMock_Guts_MemChain(Mock.BTM_sendCmd_CallInstance, cmock_guts_index);
  Mock.BTM_sendCmd_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_BTM_sendCmd(cmock_call_instance, command);
}

void BTM_sendCmd_AddCallback(CMOCK_BTM_sendCmd_CALLBACK Callback)
{
  Mock.BTM_sendCmd_IgnoreBool = (char)0;
  Mock.BTM_sendCmd_CallbackBool = (char)1;
  Mock.BTM_sendCmd_CallbackFunctionPointer = Callback;
}

void BTM_sendCmd_Stub(CMOCK_BTM_sendCmd_CALLBACK Callback)
{
  Mock.BTM_sendCmd_IgnoreBool = (char)0;
  Mock.BTM_sendCmd_CallbackBool = (char)0;
  Mock.BTM_sendCmd_CallbackFunctionPointer = Callback;
}

BTM_Status_t BTM_sendCmdAndPoll(BTM_command_t command)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_BTM_sendCmdAndPoll_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_BTM_sendCmdAndPoll);
  cmock_call_instance = (CMOCK_BTM_sendCmdAndPoll_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.BTM_sendCmdAndPoll_CallInstance);
  Mock.BTM_sendCmdAndPoll_CallInstance = CMock_Guts_MemNext(Mock.BTM_sendCmdAndPoll_CallInstance);
  if (Mock.BTM_sendCmdAndPoll_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.BTM_sendCmdAndPoll_FinalReturn;
    memcpy((void*)(&Mock.BTM_sendCmdAndPoll_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BTM_Status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BTM_Status_t) ? 1 : -1])); /* add BTM_Status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.BTM_sendCmdAndPoll_CallbackBool &&
      Mock.BTM_sendCmdAndPoll_CallbackFunctionPointer != NULL)
  {
    BTM_Status_t cmock_cb_ret = Mock.BTM_sendCmdAndPoll_CallbackFunctionPointer(command, Mock.BTM_sendCmdAndPoll_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_BTM_sendCmdAndPoll,CMockString_command);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_command), (void*)(&command), sizeof(BTM_command_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.BTM_sendCmdAndPoll_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.BTM_sendCmdAndPoll_CallbackFunctionPointer(command, Mock.BTM_sendCmdAndPoll_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_BTM_sendCmdAndPoll(CMOCK_BTM_sendCmdAndPoll_CALL_INSTANCE* cmock_call_instance, BTM_command_t command);
void CMockExpectParameters_BTM_sendCmdAndPoll(CMOCK_BTM_sendCmdAndPoll_CALL_INSTANCE* cmock_call_instance, BTM_command_t command)
{
  memcpy((void*)(&cmock_call_instance->Expected_command), (void*)(&command),
         sizeof(BTM_command_t[sizeof(command) == sizeof(BTM_command_t) ? 1 : -1])); /* add BTM_command_t to :treat_as_array if this causes an error */
}

void BTM_sendCmdAndPoll_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BTM_Status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_BTM_sendCmdAndPoll_CALL_INSTANCE));
  CMOCK_BTM_sendCmdAndPoll_CALL_INSTANCE* cmock_call_instance = (CMOCK_BTM_sendCmdAndPoll_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.BTM_sendCmdAndPoll_CallInstance = CMock_Guts_MemChain(Mock.BTM_sendCmdAndPoll_CallInstance, cmock_guts_index);
  Mock.BTM_sendCmdAndPoll_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.BTM_sendCmdAndPoll_IgnoreBool = (char)1;
}

void BTM_sendCmdAndPoll_CMockStopIgnore(void)
{
  if(Mock.BTM_sendCmdAndPoll_IgnoreBool)
    Mock.BTM_sendCmdAndPoll_CallInstance = CMock_Guts_MemNext(Mock.BTM_sendCmdAndPoll_CallInstance);
  Mock.BTM_sendCmdAndPoll_IgnoreBool = (char)0;
}

void BTM_sendCmdAndPoll_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, BTM_command_t command, BTM_Status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_BTM_sendCmdAndPoll_CALL_INSTANCE));
  CMOCK_BTM_sendCmdAndPoll_CALL_INSTANCE* cmock_call_instance = (CMOCK_BTM_sendCmdAndPoll_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.BTM_sendCmdAndPoll_CallInstance = CMock_Guts_MemChain(Mock.BTM_sendCmdAndPoll_CallInstance, cmock_guts_index);
  Mock.BTM_sendCmdAndPoll_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_BTM_sendCmdAndPoll(cmock_call_instance, command);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BTM_Status_t[sizeof(cmock_to_return) == sizeof(BTM_Status_t) ? 1 : -1])); /* add BTM_Status_t to :treat_as_array if this causes an error */
}

void BTM_sendCmdAndPoll_AddCallback(CMOCK_BTM_sendCmdAndPoll_CALLBACK Callback)
{
  Mock.BTM_sendCmdAndPoll_IgnoreBool = (char)0;
  Mock.BTM_sendCmdAndPoll_CallbackBool = (char)1;
  Mock.BTM_sendCmdAndPoll_CallbackFunctionPointer = Callback;
}

void BTM_sendCmdAndPoll_Stub(CMOCK_BTM_sendCmdAndPoll_CALLBACK Callback)
{
  Mock.BTM_sendCmdAndPoll_IgnoreBool = (char)0;
  Mock.BTM_sendCmdAndPoll_CallbackBool = (char)0;
  Mock.BTM_sendCmdAndPoll_CallbackFunctionPointer = Callback;
}

void BTM_writeRegisterGroup(BTM_command_t command, uint8_t tx_data[][6])
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_BTM_writeRegisterGroup_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_BTM_writeRegisterGroup);
  cmock_call_instance = (CMOCK_BTM_writeRegisterGroup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.BTM_writeRegisterGroup_CallInstance);
  Mock.BTM_writeRegisterGroup_CallInstance = CMock_Guts_MemNext(Mock.BTM_writeRegisterGroup_CallInstance);
  if (Mock.BTM_writeRegisterGroup_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.BTM_writeRegisterGroup_CallbackBool &&
      Mock.BTM_writeRegisterGroup_CallbackFunctionPointer != NULL)
  {
    Mock.BTM_writeRegisterGroup_CallbackFunctionPointer(command, tx_data, Mock.BTM_writeRegisterGroup_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_BTM_writeRegisterGroup,CMockString_command);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_command), (void*)(&command), sizeof(BTM_command_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_BTM_writeRegisterGroup,CMockString_tx_data);
    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_tx_data, tx_data, cmock_line, CMockStringMismatch);
  }
  if (Mock.BTM_writeRegisterGroup_CallbackFunctionPointer != NULL)
  {
    Mock.BTM_writeRegisterGroup_CallbackFunctionPointer(command, tx_data, Mock.BTM_writeRegisterGroup_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_BTM_writeRegisterGroup(CMOCK_BTM_writeRegisterGroup_CALL_INSTANCE* cmock_call_instance, BTM_command_t command, uint8_t** tx_data);
void CMockExpectParameters_BTM_writeRegisterGroup(CMOCK_BTM_writeRegisterGroup_CALL_INSTANCE* cmock_call_instance, BTM_command_t command, uint8_t** tx_data)
{
  memcpy((void*)(&cmock_call_instance->Expected_command), (void*)(&command),
         sizeof(BTM_command_t[sizeof(command) == sizeof(BTM_command_t) ? 1 : -1])); /* add BTM_command_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_tx_data = tx_data;
}

void BTM_writeRegisterGroup_CMockIgnore(void)
{
  Mock.BTM_writeRegisterGroup_IgnoreBool = (char)1;
}

void BTM_writeRegisterGroup_CMockStopIgnore(void)
{
  Mock.BTM_writeRegisterGroup_IgnoreBool = (char)0;
}

void BTM_writeRegisterGroup_CMockExpect(UNITY_LINE_TYPE cmock_line, BTM_command_t command, uint8_t** tx_data)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_BTM_writeRegisterGroup_CALL_INSTANCE));
  CMOCK_BTM_writeRegisterGroup_CALL_INSTANCE* cmock_call_instance = (CMOCK_BTM_writeRegisterGroup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.BTM_writeRegisterGroup_CallInstance = CMock_Guts_MemChain(Mock.BTM_writeRegisterGroup_CallInstance, cmock_guts_index);
  Mock.BTM_writeRegisterGroup_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_BTM_writeRegisterGroup(cmock_call_instance, command, tx_data);
}

void BTM_writeRegisterGroup_AddCallback(CMOCK_BTM_writeRegisterGroup_CALLBACK Callback)
{
  Mock.BTM_writeRegisterGroup_IgnoreBool = (char)0;
  Mock.BTM_writeRegisterGroup_CallbackBool = (char)1;
  Mock.BTM_writeRegisterGroup_CallbackFunctionPointer = Callback;
}

void BTM_writeRegisterGroup_Stub(CMOCK_BTM_writeRegisterGroup_CALLBACK Callback)
{
  Mock.BTM_writeRegisterGroup_IgnoreBool = (char)0;
  Mock.BTM_writeRegisterGroup_CallbackBool = (char)0;
  Mock.BTM_writeRegisterGroup_CallbackFunctionPointer = Callback;
}

BTM_Status_t BTM_readRegisterGroup(BTM_command_t command, uint8_t rx_data[][6])
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_BTM_readRegisterGroup_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_BTM_readRegisterGroup);
  cmock_call_instance = (CMOCK_BTM_readRegisterGroup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.BTM_readRegisterGroup_CallInstance);
  Mock.BTM_readRegisterGroup_CallInstance = CMock_Guts_MemNext(Mock.BTM_readRegisterGroup_CallInstance);
  if (Mock.BTM_readRegisterGroup_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.BTM_readRegisterGroup_FinalReturn;
    memcpy((void*)(&Mock.BTM_readRegisterGroup_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BTM_Status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BTM_Status_t) ? 1 : -1])); /* add BTM_Status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.BTM_readRegisterGroup_CallbackBool &&
      Mock.BTM_readRegisterGroup_CallbackFunctionPointer != NULL)
  {
    BTM_Status_t cmock_cb_ret = Mock.BTM_readRegisterGroup_CallbackFunctionPointer(command, rx_data, Mock.BTM_readRegisterGroup_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_BTM_readRegisterGroup,CMockString_command);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_command), (void*)(&command), sizeof(BTM_command_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_BTM_readRegisterGroup,CMockString_rx_data);
    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_rx_data, rx_data, cmock_line, CMockStringMismatch);
  }
  if (Mock.BTM_readRegisterGroup_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.BTM_readRegisterGroup_CallbackFunctionPointer(command, rx_data, Mock.BTM_readRegisterGroup_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_BTM_readRegisterGroup(CMOCK_BTM_readRegisterGroup_CALL_INSTANCE* cmock_call_instance, BTM_command_t command, uint8_t** rx_data);
void CMockExpectParameters_BTM_readRegisterGroup(CMOCK_BTM_readRegisterGroup_CALL_INSTANCE* cmock_call_instance, BTM_command_t command, uint8_t** rx_data)
{
  memcpy((void*)(&cmock_call_instance->Expected_command), (void*)(&command),
         sizeof(BTM_command_t[sizeof(command) == sizeof(BTM_command_t) ? 1 : -1])); /* add BTM_command_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_rx_data = rx_data;
}

void BTM_readRegisterGroup_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BTM_Status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_BTM_readRegisterGroup_CALL_INSTANCE));
  CMOCK_BTM_readRegisterGroup_CALL_INSTANCE* cmock_call_instance = (CMOCK_BTM_readRegisterGroup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.BTM_readRegisterGroup_CallInstance = CMock_Guts_MemChain(Mock.BTM_readRegisterGroup_CallInstance, cmock_guts_index);
  Mock.BTM_readRegisterGroup_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.BTM_readRegisterGroup_IgnoreBool = (char)1;
}

void BTM_readRegisterGroup_CMockStopIgnore(void)
{
  if(Mock.BTM_readRegisterGroup_IgnoreBool)
    Mock.BTM_readRegisterGroup_CallInstance = CMock_Guts_MemNext(Mock.BTM_readRegisterGroup_CallInstance);
  Mock.BTM_readRegisterGroup_IgnoreBool = (char)0;
}

void BTM_readRegisterGroup_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, BTM_command_t command, uint8_t** rx_data, BTM_Status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_BTM_readRegisterGroup_CALL_INSTANCE));
  CMOCK_BTM_readRegisterGroup_CALL_INSTANCE* cmock_call_instance = (CMOCK_BTM_readRegisterGroup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.BTM_readRegisterGroup_CallInstance = CMock_Guts_MemChain(Mock.BTM_readRegisterGroup_CallInstance, cmock_guts_index);
  Mock.BTM_readRegisterGroup_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_BTM_readRegisterGroup(cmock_call_instance, command, rx_data);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BTM_Status_t[sizeof(cmock_to_return) == sizeof(BTM_Status_t) ? 1 : -1])); /* add BTM_Status_t to :treat_as_array if this causes an error */
}

void BTM_readRegisterGroup_AddCallback(CMOCK_BTM_readRegisterGroup_CALLBACK Callback)
{
  Mock.BTM_readRegisterGroup_IgnoreBool = (char)0;
  Mock.BTM_readRegisterGroup_CallbackBool = (char)1;
  Mock.BTM_readRegisterGroup_CallbackFunctionPointer = Callback;
}

void BTM_readRegisterGroup_Stub(CMOCK_BTM_readRegisterGroup_CALLBACK Callback)
{
  Mock.BTM_readRegisterGroup_IgnoreBool = (char)0;
  Mock.BTM_readRegisterGroup_CallbackBool = (char)0;
  Mock.BTM_readRegisterGroup_CallbackFunctionPointer = Callback;
}

BTM_Status_t BTM_readBatt(BTM_PackData_t * packData)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_BTM_readBatt_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_BTM_readBatt);
  cmock_call_instance = (CMOCK_BTM_readBatt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.BTM_readBatt_CallInstance);
  Mock.BTM_readBatt_CallInstance = CMock_Guts_MemNext(Mock.BTM_readBatt_CallInstance);
  if (Mock.BTM_readBatt_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.BTM_readBatt_FinalReturn;
    memcpy((void*)(&Mock.BTM_readBatt_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BTM_Status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BTM_Status_t) ? 1 : -1])); /* add BTM_Status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.BTM_readBatt_CallbackBool &&
      Mock.BTM_readBatt_CallbackFunctionPointer != NULL)
  {
    BTM_Status_t cmock_cb_ret = Mock.BTM_readBatt_CallbackFunctionPointer(packData, Mock.BTM_readBatt_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_BTM_readBatt,CMockString_packData);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_packData), (void*)(packData), sizeof(BTM_PackData_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.BTM_readBatt_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.BTM_readBatt_CallbackFunctionPointer(packData, Mock.BTM_readBatt_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_BTM_readBatt(CMOCK_BTM_readBatt_CALL_INSTANCE* cmock_call_instance, BTM_PackData_t* packData);
void CMockExpectParameters_BTM_readBatt(CMOCK_BTM_readBatt_CALL_INSTANCE* cmock_call_instance, BTM_PackData_t* packData)
{
  cmock_call_instance->Expected_packData = packData;
}

void BTM_readBatt_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BTM_Status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_BTM_readBatt_CALL_INSTANCE));
  CMOCK_BTM_readBatt_CALL_INSTANCE* cmock_call_instance = (CMOCK_BTM_readBatt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.BTM_readBatt_CallInstance = CMock_Guts_MemChain(Mock.BTM_readBatt_CallInstance, cmock_guts_index);
  Mock.BTM_readBatt_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.BTM_readBatt_IgnoreBool = (char)1;
}

void BTM_readBatt_CMockStopIgnore(void)
{
  if(Mock.BTM_readBatt_IgnoreBool)
    Mock.BTM_readBatt_CallInstance = CMock_Guts_MemNext(Mock.BTM_readBatt_CallInstance);
  Mock.BTM_readBatt_IgnoreBool = (char)0;
}

void BTM_readBatt_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, BTM_PackData_t* packData, BTM_Status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_BTM_readBatt_CALL_INSTANCE));
  CMOCK_BTM_readBatt_CALL_INSTANCE* cmock_call_instance = (CMOCK_BTM_readBatt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.BTM_readBatt_CallInstance = CMock_Guts_MemChain(Mock.BTM_readBatt_CallInstance, cmock_guts_index);
  Mock.BTM_readBatt_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_BTM_readBatt(cmock_call_instance, packData);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BTM_Status_t[sizeof(cmock_to_return) == sizeof(BTM_Status_t) ? 1 : -1])); /* add BTM_Status_t to :treat_as_array if this causes an error */
}

void BTM_readBatt_AddCallback(CMOCK_BTM_readBatt_CALLBACK Callback)
{
  Mock.BTM_readBatt_IgnoreBool = (char)0;
  Mock.BTM_readBatt_CallbackBool = (char)1;
  Mock.BTM_readBatt_CallbackFunctionPointer = Callback;
}

void BTM_readBatt_Stub(CMOCK_BTM_readBatt_CALLBACK Callback)
{
  Mock.BTM_readBatt_IgnoreBool = (char)0;
  Mock.BTM_readBatt_CallbackBool = (char)0;
  Mock.BTM_readBatt_CallbackFunctionPointer = Callback;
}

float BTM_regValToVoltage(unsigned int raw_reading)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_BTM_regValToVoltage_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_BTM_regValToVoltage);
  cmock_call_instance = (CMOCK_BTM_regValToVoltage_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.BTM_regValToVoltage_CallInstance);
  Mock.BTM_regValToVoltage_CallInstance = CMock_Guts_MemNext(Mock.BTM_regValToVoltage_CallInstance);
  if (Mock.BTM_regValToVoltage_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.BTM_regValToVoltage_FinalReturn;
    Mock.BTM_regValToVoltage_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.BTM_regValToVoltage_CallbackBool &&
      Mock.BTM_regValToVoltage_CallbackFunctionPointer != NULL)
  {
    float cmock_cb_ret = Mock.BTM_regValToVoltage_CallbackFunctionPointer(raw_reading, Mock.BTM_regValToVoltage_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_BTM_regValToVoltage,CMockString_raw_reading);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_raw_reading, raw_reading, cmock_line, CMockStringMismatch);
  }
  if (Mock.BTM_regValToVoltage_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.BTM_regValToVoltage_CallbackFunctionPointer(raw_reading, Mock.BTM_regValToVoltage_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_BTM_regValToVoltage(CMOCK_BTM_regValToVoltage_CALL_INSTANCE* cmock_call_instance, unsigned int raw_reading);
void CMockExpectParameters_BTM_regValToVoltage(CMOCK_BTM_regValToVoltage_CALL_INSTANCE* cmock_call_instance, unsigned int raw_reading)
{
  cmock_call_instance->Expected_raw_reading = raw_reading;
}

void BTM_regValToVoltage_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, float cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_BTM_regValToVoltage_CALL_INSTANCE));
  CMOCK_BTM_regValToVoltage_CALL_INSTANCE* cmock_call_instance = (CMOCK_BTM_regValToVoltage_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.BTM_regValToVoltage_CallInstance = CMock_Guts_MemChain(Mock.BTM_regValToVoltage_CallInstance, cmock_guts_index);
  Mock.BTM_regValToVoltage_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.BTM_regValToVoltage_IgnoreBool = (char)1;
}

void BTM_regValToVoltage_CMockStopIgnore(void)
{
  if(Mock.BTM_regValToVoltage_IgnoreBool)
    Mock.BTM_regValToVoltage_CallInstance = CMock_Guts_MemNext(Mock.BTM_regValToVoltage_CallInstance);
  Mock.BTM_regValToVoltage_IgnoreBool = (char)0;
}

void BTM_regValToVoltage_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, unsigned int raw_reading, float cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_BTM_regValToVoltage_CALL_INSTANCE));
  CMOCK_BTM_regValToVoltage_CALL_INSTANCE* cmock_call_instance = (CMOCK_BTM_regValToVoltage_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.BTM_regValToVoltage_CallInstance = CMock_Guts_MemChain(Mock.BTM_regValToVoltage_CallInstance, cmock_guts_index);
  Mock.BTM_regValToVoltage_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_BTM_regValToVoltage(cmock_call_instance, raw_reading);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void BTM_regValToVoltage_AddCallback(CMOCK_BTM_regValToVoltage_CALLBACK Callback)
{
  Mock.BTM_regValToVoltage_IgnoreBool = (char)0;
  Mock.BTM_regValToVoltage_CallbackBool = (char)1;
  Mock.BTM_regValToVoltage_CallbackFunctionPointer = Callback;
}

void BTM_regValToVoltage_Stub(CMOCK_BTM_regValToVoltage_CALLBACK Callback)
{
  Mock.BTM_regValToVoltage_IgnoreBool = (char)0;
  Mock.BTM_regValToVoltage_CallbackBool = (char)0;
  Mock.BTM_regValToVoltage_CallbackFunctionPointer = Callback;
}

void BTM_writeCS(CS_state_t new_state)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_BTM_writeCS_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_BTM_writeCS);
  cmock_call_instance = (CMOCK_BTM_writeCS_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.BTM_writeCS_CallInstance);
  Mock.BTM_writeCS_CallInstance = CMock_Guts_MemNext(Mock.BTM_writeCS_CallInstance);
  if (Mock.BTM_writeCS_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.BTM_writeCS_CallbackBool &&
      Mock.BTM_writeCS_CallbackFunctionPointer != NULL)
  {
    Mock.BTM_writeCS_CallbackFunctionPointer(new_state, Mock.BTM_writeCS_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_BTM_writeCS,CMockString_new_state);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_new_state), (void*)(&new_state), sizeof(CS_state_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.BTM_writeCS_CallbackFunctionPointer != NULL)
  {
    Mock.BTM_writeCS_CallbackFunctionPointer(new_state, Mock.BTM_writeCS_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_BTM_writeCS(CMOCK_BTM_writeCS_CALL_INSTANCE* cmock_call_instance, CS_state_t new_state);
void CMockExpectParameters_BTM_writeCS(CMOCK_BTM_writeCS_CALL_INSTANCE* cmock_call_instance, CS_state_t new_state)
{
  memcpy((void*)(&cmock_call_instance->Expected_new_state), (void*)(&new_state),
         sizeof(CS_state_t[sizeof(new_state) == sizeof(CS_state_t) ? 1 : -1])); /* add CS_state_t to :treat_as_array if this causes an error */
}

void BTM_writeCS_CMockIgnore(void)
{
  Mock.BTM_writeCS_IgnoreBool = (char)1;
}

void BTM_writeCS_CMockStopIgnore(void)
{
  Mock.BTM_writeCS_IgnoreBool = (char)0;
}

void BTM_writeCS_CMockExpect(UNITY_LINE_TYPE cmock_line, CS_state_t new_state)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_BTM_writeCS_CALL_INSTANCE));
  CMOCK_BTM_writeCS_CALL_INSTANCE* cmock_call_instance = (CMOCK_BTM_writeCS_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.BTM_writeCS_CallInstance = CMock_Guts_MemChain(Mock.BTM_writeCS_CallInstance, cmock_guts_index);
  Mock.BTM_writeCS_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_BTM_writeCS(cmock_call_instance, new_state);
}

void BTM_writeCS_AddCallback(CMOCK_BTM_writeCS_CALLBACK Callback)
{
  Mock.BTM_writeCS_IgnoreBool = (char)0;
  Mock.BTM_writeCS_CallbackBool = (char)1;
  Mock.BTM_writeCS_CallbackFunctionPointer = Callback;
}

void BTM_writeCS_Stub(CMOCK_BTM_writeCS_CALLBACK Callback)
{
  Mock.BTM_writeCS_IgnoreBool = (char)0;
  Mock.BTM_writeCS_CallbackBool = (char)0;
  Mock.BTM_writeCS_CallbackFunctionPointer = Callback;
}

